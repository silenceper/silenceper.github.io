<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on silenceper</title>
    <link>/posts/</link>
    <description>Recent content in Posts on silenceper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 10 Jul 2020 14:20:59 +0800</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>将镜像tar包通过API直接push到registry仓库</title>
      <link>/blog/202007/docker-tar-push/</link>
      <pubDate>Fri, 10 Jul 2020 14:20:59 +0800</pubDate>
      
      <guid>/blog/202007/docker-tar-push/</guid>
      <description>为了实现docker tar包能够直接通过页面上传，调研了一下registry的api，以及如何解析tar包（其实就是docker daemon</description>
    </item>
    
    <item>
      <title>在x86_64机器上构建arm64镜像</title>
      <link>/blog/202006/build-arm-image-on-x86_84/</link>
      <pubDate>Fri, 05 Jun 2020 14:20:59 +0800</pubDate>
      
      <guid>/blog/202006/build-arm-image-on-x86_84/</guid>
      <description>有几种办法可以打包出arm64的镜像 直接在arm机器上执行编译和打包 通过qemu模拟arm环境 利用docker提供的buildx（需要启用试</description>
    </item>
    
    <item>
      <title>如何在Kubernetes中创建一个自定义Controller?</title>
      <link>/blog/202005/custom-resources-and-controllers/</link>
      <pubDate>Mon, 18 May 2020 18:20:59 +0800</pubDate>
      
      <guid>/blog/202005/custom-resources-and-controllers/</guid>
      <description>目的 Custom Resource是扩展Kubernetes的一种方式（另外一种就是通过聚合层API apiserver-aggregation），而co</description>
    </item>
    
    <item>
      <title>用vim保存文件和echo命令到底有什么不同？</title>
      <link>/blog/202005/difference-vim-and-echo/</link>
      <pubDate>Wed, 13 May 2020 20:20:59 +0800</pubDate>
      
      <guid>/blog/202005/difference-vim-and-echo/</guid>
      <description>现象 最近在调试一个filebeat程序时需要制造一些log，我是直接使用vim直接对文件打开然后直接保存的。 但是有个奇怪的现象：每次写入一行</description>
    </item>
    
    <item>
      <title>postgres入门</title>
      <link>/blog/202005/getting-started-with-postgres/</link>
      <pubDate>Mon, 04 May 2020 23:20:59 +0800</pubDate>
      
      <guid>/blog/202005/getting-started-with-postgres/</guid>
      <description>最近需要将mysql数据库切换到pg数据库（公司要求新上的应用DB首选postgres），所以对pg进行基本学习了下，总体感觉相差不大，在一</description>
    </item>
    
    <item>
      <title>记一次问题排查：为什么在POD无法通过Service访问自己？</title>
      <link>/blog/202004/bridge-hairpin-mod/</link>
      <pubDate>Thu, 30 Apr 2020 11:26:59 +0800</pubDate>
      
      <guid>/blog/202004/bridge-hairpin-mod/</guid>
      <description>问题现象 创建一个nginx pod，并配置了service访问，service后端指向pod。 进入pod中使用service ip 或者servic</description>
    </item>
    
    <item>
      <title>singleflight包原理解析</title>
      <link>/blog/202003/singleflight/</link>
      <pubDate>Sun, 08 Mar 2020 19:26:59 +0800</pubDate>
      
      <guid>/blog/202003/singleflight/</guid>
      <description>singleflight 包主要是用来做并发控制，常见的比如防止 缓存击穿 ，我们来模拟一下这种场景： 缓存击穿：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key</description>
    </item>
    
    <item>
      <title>分析kubernetes中的事件机制</title>
      <link>/blog/202003/kubernetes-event/</link>
      <pubDate>Tue, 03 Mar 2020 12:40:59 +0800</pubDate>
      
      <guid>/blog/202003/kubernetes-event/</guid>
      <description>我们通过 kubectl describe [资源] 命令，可以在看到Event输出，并且经常依赖event进行问题定位，从event中可以分析整个POD的运行轨迹，为服务的</description>
    </item>
    
    <item>
      <title>利用Kubernetes中的leaderelection实现组件高可用</title>
      <link>/blog/202002/kubernetes-leaderelection/</link>
      <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/202002/kubernetes-leaderelection/</guid>
      <description>在Kubernetes中，通常kube-schduler和kube-controller-manager都是多副本进行部署的来保证高可用，而</description>
    </item>
    
    <item>
      <title>如何在Go项目中输出版本信息？</title>
      <link>/blog/202001/go-import-version/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/202001/go-import-version/</guid>
      <description>我们经常在使用CLI工具的时候，都会有这样的参数输出： 1 2 3 4 5 6 7 8 9 10 ➜ ~ docker version Client: Docker Engine - Community Version: 18.09.2 API version: 1.39 Go version: go1.10.8 Git commit: 6247962 Built: Sun Feb 10 04:12:39 2019 OS/Arch: darwin/amd64 Experimental: false ➜ ~ 可</description>
    </item>
    
    <item>
      <title>Kubernetes容器日志收集方案</title>
      <link>/blog/201910/kubernetes-log/</link>
      <pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/201910/kubernetes-log/</guid>
      <description>收集POD中container日志，日志还分为两种一种是容器标准输出日志和容器内日志。 方案 从日志的采集方式上，在我看来方案大致主要分为两种：</description>
    </item>
    
    <item>
      <title>Cluster Autoscaler:集群自动扩缩容</title>
      <link>/blog/201907/cluster-autoscaler-usage/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/201907/cluster-autoscaler-usage/</guid>
      <description>Cluster AutoScaler 是一个自动扩展和收缩 Kubernetes 集群 Node 的扩展。当集群容量不足时，它会自动去 Cloud Provider （支持 GCE、GKE 和 AWS）创建新的 Node，而在 Node 长时间资源利用</description>
    </item>
    
    <item>
      <title>k8s网络组件：calico</title>
      <link>/blog/201810/calico-in-k8s/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/201810/calico-in-k8s/</guid>
      <description>前提已经安装好k8s集群 安装 calico 安装其实很简单，已经集成在两个yaml文件中 calico 版本: v3.2.3 安装必看 如果安装过flannel组件，需要先去除dock</description>
    </item>
    
    <item>
      <title>k8s网络组件：flannel</title>
      <link>/blog/201809/flannel-in-k8s/</link>
      <pubDate>Wed, 26 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/201809/flannel-in-k8s/</guid>
      <description>Flannel是一个专门为k8s定制的网络解决方案，主要解决POD跨主机通信问题，这里主要讲述Flannel是如何实现的。 安装 集成在k8s上</description>
    </item>
    
    <item>
      <title>k8s源码阅读(一)：源码结构</title>
      <link>/blog/201809/k8s-source-code-structure/</link>
      <pubDate>Wed, 12 Sep 2018 11:45:59 +0800</pubDate>
      
      <guid>/blog/201809/k8s-source-code-structure/</guid>
      <description>环境 k8s代码版本：release-1.9 工具：vscode, dlv 下载代码，并放入gopath中，方便编译： 1 2 $ mkdir -p $GOPATH/src/k8s.io &amp;amp;&amp;amp; cd $GOPATH/src/k8s.io $ git clone https://github.com/kubernetes/kubernetes # 有墙 代</description>
    </item>
    
    <item>
      <title>docker pull 翻墙下载镜像</title>
      <link>/blog/201809/over-the-wall-pull-docker-mirror/</link>
      <pubDate>Sun, 09 Sep 2018 11:45:59 +0800</pubDate>
      
      <guid>/blog/201809/over-the-wall-pull-docker-mirror/</guid>
      <description>我们一般通过设置http_proxy环境变量，使得http请求，可以走我们设置的proxy，（一些go get镜像无法下载可以这么用），但是对</description>
    </item>
    
    <item>
      <title>在CentOS上搭建Kubernetes集群</title>
      <link>/blog/201809/how-to-build-a-k8s-cluster/</link>
      <pubDate>Fri, 07 Sep 2018 11:45:59 +0800</pubDate>
      
      <guid>/blog/201809/how-to-build-a-k8s-cluster/</guid>
      <description>以下是我自己在部署k8s集群上做的一些记录，部署了一个master，一个node节点。 环境准备 我在VirtualBox中建的两个CentOS</description>
    </item>
    
    <item>
      <title>聊聊连接池</title>
      <link>/blog/201611/tcp_connection_pool/</link>
      <pubDate>Sun, 20 Nov 2016 02:40:59 +0800</pubDate>
      
      <guid>/blog/201611/tcp_connection_pool/</guid>
      <description>以下主要使用Golang作为编程语言 为什么需要连接池 我觉得使用连接池最大的一个好处就是减少连接的创建和关闭，增加系统负载能力， 之前就有遇到一</description>
    </item>
    
    <item>
      <title>开源项目：wechat sdk</title>
      <link>/blog/201609/go-wechat-sdk/</link>
      <pubDate>Fri, 16 Sep 2016 15:40:59 +0800</pubDate>
      
      <guid>/blog/201609/go-wechat-sdk/</guid>
      <description>一直很想自己用golang写个微信的sdk，目标是简单好用，所以利用闲暇时间（周末，中秋😁），就做出来。 项目地址:https://githu</description>
    </item>
    
    <item>
      <title>dcmp</title>
      <link>/blog/201608/dcmp/</link>
      <pubDate>Tue, 02 Aug 2016 15:40:59 +0800</pubDate>
      
      <guid>/blog/201608/dcmp/</guid>
      <description>Distributed Configuration Management Platform 提供了一个etcd的管理界面，可通过界面修改配置信息，借助confd可实现配置文件的同步。 dcmp image GITHUB：https://gith</description>
    </item>
    
    <item>
      <title>Golang中http包默认路由匹配规则阅读笔记</title>
      <link>/blog/201605/go-http-process/</link>
      <pubDate>Sat, 28 May 2016 18:00:59 +0800</pubDate>
      
      <guid>/blog/201605/go-http-process/</guid>
      <description>一、执行流程 构建一个简单http server： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;#34;hello world&amp;#34;)) }) log.Fatal(http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil)) } 使用http://12</description>
    </item>
    
    <item>
      <title>tcp time_wait问题</title>
      <link>/blog/201601/tcp_time_wait_error/</link>
      <pubDate>Sun, 03 Jan 2016 15:40:59 +0800</pubDate>
      
      <guid>/blog/201601/tcp_time_wait_error/</guid>
      <description>问题出现： 在元旦前夕，自己维护的一个服务突然在高峰时期收到大量报警，赶紧登上服务器看一下： 最开始的反应是memcache tcp read time out ,因为之前也</description>
    </item>
    
  </channel>
</rss>